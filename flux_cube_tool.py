#!/usr/bin/env python3
"""Utility helpers for working with precomputed flux cubes.

This module exposes a small command line tool that can

* read the ``flux_cube.bin`` files generated by ``precompute_flux_cube.py``
* evaluate the spectral energy distribution (SED) at arbitrary
  combinations of (teff, logg, metallicity) using cubic Hermite
  interpolation in each axis
* compute bolometric fluxes / magnitudes
* fold SEDs through user supplied filter transmission curves
* create quick-look plots for the interpolated SED (and filters)

The binary format that :func:`precompute_flux_cube` writes is::

    int32 nt, nl, nm, nw
    float64[nt] teff_grid
    float64[nl] logg_grid
    float64[nm] meta_grid
    float64[nw] wavelengths
    float64[nw * nm * nl * nt] flux values stored with the trailing
        dimensions ordered as (wavelength, metallicity, logg, teff)

When loaded we restore the more natural shape
``(nt, nl, nm, nw)``.

Example usage from the command line::

    python flux_cube_tool.py \
        --flux-cube data/stellar_models/MODEL/flux_cube.bin \
        --teff 6000 --logg 4.5 --metallicity 0.0 \
        --filters data/filters/Johnson/U.dat data/filters/Johnson/B.dat \
        --plot sed.png --save-sed sed.csv

The CLI prints the bolometric flux / magnitude and the synthetic
photometry in each requested filter.  The plot overlays any supplied
filters (scaled to the SED peak) for visual sanity checks.
"""

from __future__ import annotations

import argparse
import math
import os
import struct
from dataclasses import dataclass
from typing import Dict, Iterable, List, Sequence, Tuple

import matplotlib.pyplot as plt
import numpy as np


@dataclass
class FluxCube:
    """In-memory representation of a pre-computed flux cube."""

    teff_grid: np.ndarray
    logg_grid: np.ndarray
    meta_grid: np.ndarray
    wavelengths: np.ndarray
    flux: np.ndarray  # shape (nt, nl, nm, nw)

    @classmethod
    def from_file(cls, path: str) -> "FluxCube":
        """Load a :class:`FluxCube` from a binary file."""

        with open(path, "rb") as fh:
            header = fh.read(16)
            if len(header) != 16:
                raise ValueError("Flux cube header truncated")
            nt, nl, nm, nw = struct.unpack("4i", header)
            teff = np.fromfile(fh, dtype=np.float64, count=nt)
            logg = np.fromfile(fh, dtype=np.float64, count=nl)
            meta = np.fromfile(fh, dtype=np.float64, count=nm)
            wavelengths = np.fromfile(fh, dtype=np.float64, count=nw)
            flux_expected = nt * nl * nm * nw
            flux_flat = np.fromfile(fh, dtype=np.float64)

        if flux_flat.size != flux_expected:
            raise ValueError(
                f"Flux cube body truncated: expected {flux_expected} values,"
                f" found {flux_flat.size}"
            )

        # Restore original (nt, nl, nm, nw) ordering.
        flux = flux_flat.reshape((nw, nm, nl, nt)).transpose(3, 2, 1, 0)

        return cls(teff, logg, meta, wavelengths, flux)

    # ------------------------------------------------------------------
    # Interpolation helpers

    def _hermite_interp_axis(
        self, values: np.ndarray, grid: np.ndarray, x: float, axis: int
    ) -> np.ndarray:
        """Perform cubic Hermite interpolation along one axis."""

        if values.shape[axis] < 2:
            raise ValueError("Need at least two grid points for Hermite interpolation")

        if not (grid[0] <= x <= grid[-1]):
            raise ValueError(
                f"Requested value {x} is outside interpolation range"
                f" [{grid[0]}, {grid[-1]}]"
            )

        idx = int(np.searchsorted(grid, x) - 1)
        idx = max(0, min(idx, len(grid) - 2))

        x0 = grid[idx]
        x1 = grid[idx + 1]
        h = x1 - x0
        t = (x - x0) / h if h != 0 else 0.0

        f0 = np.take(values, idx, axis=axis)
        f1 = np.take(values, idx + 1, axis=axis)

        m0 = self._axis_derivative(values, grid, idx, axis)
        m1 = self._axis_derivative(values, grid, idx + 1, axis)

        h00 = (2 * t**3) - (3 * t**2) + 1
        h10 = (t**3) - (2 * t**2) + t
        h01 = (-2 * t**3) + (3 * t**2)
        h11 = (t**3) - (t**2)

        return h00 * f0 + h10 * h * m0 + h01 * f1 + h11 * h * m1

    def _axis_derivative(
        self, values: np.ndarray, grid: np.ndarray, idx: int, axis: int
    ) -> np.ndarray:
        n = len(grid)

        if idx <= 0:
            f0 = np.take(values, 0, axis=axis)
            f1 = np.take(values, 1, axis=axis)
            return (f1 - f0) / (grid[1] - grid[0])
        if idx >= n - 1:
            f0 = np.take(values, n - 2, axis=axis)
            f1 = np.take(values, n - 1, axis=axis)
            return (f1 - f0) / (grid[n - 1] - grid[n - 2])

        f_prev = np.take(values, idx - 1, axis=axis)
        f_next = np.take(values, idx + 1, axis=axis)
        x_prev = grid[idx - 1]
        x_next = grid[idx + 1]
        return (f_next - f_prev) / (x_next - x_prev)

    # ------------------------------------------------------------------

    def interpolate_spectrum(self, teff: float, logg: float, meta: float) -> Tuple[np.ndarray, np.ndarray]:
        """Return ``(wavelength, flux)`` at the requested parameter point."""

        tmp = self._hermite_interp_axis(self.flux, self.teff_grid, teff, axis=0)
        tmp = self._hermite_interp_axis(tmp, self.logg_grid, logg, axis=0)
        flux = self._hermite_interp_axis(tmp, self.meta_grid, meta, axis=0)
        return self.wavelengths.copy(), flux


def integrate_flux(wavelength: np.ndarray, flux: np.ndarray) -> float:
    """Compute bolometric flux via trapezoidal integration."""

    return float(np.trapz(flux, wavelength))


def bolometric_magnitude(
    wavelength: np.ndarray,
    flux: np.ndarray,
    reference_flux: float = 1.0,
    reference_magnitude: float = 0.0,
) -> Tuple[float, float]:
    """Return bolometric flux and magnitude."""

    fbol = integrate_flux(wavelength, flux)
    if fbol <= 0:
        mag = math.inf
    else:
        mag = reference_magnitude - 2.5 * math.log10(fbol / reference_flux)
    return fbol, mag


def load_filter_curve(path: str) -> Tuple[np.ndarray, np.ndarray]:
    """Load a two-column filter curve (wavelength, throughput)."""

    data = np.loadtxt(path, unpack=True)
    if data.shape[0] < 2:
        raise ValueError(f"Filter file {path} must contain at least two columns")
    wavelength, transmission = data[0], data[1]
    order = np.argsort(wavelength)
    return wavelength[order], transmission[order]


def filter_flux(
    sed_wavelength: np.ndarray,
    sed_flux: np.ndarray,
    filter_wavelength: np.ndarray,
    filter_transmission: np.ndarray,
) -> float:
    """Compute band-integrated flux through a filter curve."""

    interp_trans = np.interp(sed_wavelength, filter_wavelength, filter_transmission, left=0.0, right=0.0)
    numerator = np.trapz(sed_flux * interp_trans, sed_wavelength)
    denom = np.trapz(interp_trans, sed_wavelength)
    if denom == 0:
        raise ValueError("Filter transmission integrates to zero")
    return float(numerator / denom)


def filter_magnitude(
    sed_wavelength: np.ndarray,
    sed_flux: np.ndarray,
    filter_wavelength: np.ndarray,
    filter_transmission: np.ndarray,
    reference_flux: float = 1.0,
    reference_magnitude: float = 0.0,
) -> Tuple[float, float]:
    """Compute synthetic flux and magnitude for a filter."""

    f = filter_flux(sed_wavelength, sed_flux, filter_wavelength, filter_transmission)
    if f <= 0:
        mag = math.inf
    else:
        mag = reference_magnitude - 2.5 * math.log10(f / reference_flux)
    return f, mag


def plot_sed(
    wavelength: np.ndarray,
    flux: np.ndarray,
    filters: Dict[str, Tuple[np.ndarray, np.ndarray]] = None,
    out_path: str | None = None,
) -> None:
    """Plot the interpolated SED and optional filter curves."""

    plt.figure(figsize=(10, 6))
    plt.plot(wavelength, flux, label="Interpolated SED", color="C0")

    if filters:
        peak = np.max(flux) if flux.size else 1.0
        for name, (fw, ft) in filters.items():
            scaled = ft / np.max(ft) * peak if np.max(ft) != 0 else ft
            plt.plot(fw, scaled, label=f"Filter {name}")

    plt.xlabel("Wavelength")
    plt.ylabel("Flux")
    plt.title("Interpolated Spectral Energy Distribution")
    plt.legend()
    plt.grid(True, alpha=0.3)

    if out_path:
        ensure_dir(os.path.dirname(out_path) or ".")
        plt.savefig(out_path, dpi=150)
    else:
        plt.show()
    plt.close()


def ensure_dir(path: str) -> None:
    if path:
        os.makedirs(path, exist_ok=True)


def save_sed(path: str, wavelength: np.ndarray, flux: np.ndarray) -> None:
    ensure_dir(os.path.dirname(path) or ".")
    data = np.column_stack((wavelength, flux))
    header = "wavelength flux"
    np.savetxt(path, data, header=header)


def main(argv: Sequence[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Inspect and interpolate a flux cube")
    parser.add_argument("--flux-cube", required=True, help="Path to flux_cube.bin")
    parser.add_argument("--teff", type=float, required=True, help="Target effective temperature")
    parser.add_argument("--logg", type=float, required=True, help="Target log g")
    parser.add_argument("--metallicity", type=float, required=True, help="Target metallicity")
    parser.add_argument("--bolometric-reference-flux", type=float, default=1.0,
                        help="Reference flux for bolometric magnitude (default: 1)")
    parser.add_argument("--bolometric-reference-mag", type=float, default=0.0,
                        help="Reference magnitude for bolometric magnitude (default: 0)")
    parser.add_argument("--filters", nargs="*", default=[], help="Filter curve files (two-column)")
    parser.add_argument("--filter-reference-flux", type=float, default=1.0,
                        help="Reference flux for filter magnitudes")
    parser.add_argument("--filter-reference-mag", type=float, default=0.0,
                        help="Reference magnitude for filter magnitudes")
    parser.add_argument("--plot", help="Write a diagnostic plot to this path")
    parser.add_argument("--save-sed", help="Write interpolated SED (wavelength, flux) to a text file")

    args = parser.parse_args(argv)

    cube = FluxCube.from_file(args.flux_cube)

    wl, flux = cube.interpolate_spectrum(args.teff, args.logg, args.metallicity)

    fbol, mbol = bolometric_magnitude(
        wl,
        flux,
        reference_flux=args.bolometric_reference_flux,
        reference_magnitude=args.bolometric_reference_mag,
    )

    print(f"Interpolated SED at Teff={args.teff}, logg={args.logg}, [M/H]={args.metallicity}")
    print(f"Bolometric flux: {fbol:.6e}")
    if math.isfinite(mbol):
        print(f"Bolometric magnitude: {mbol:.4f}")
    else:
        print("Bolometric magnitude: undefined (non-positive flux)")

    filters: Dict[str, Tuple[np.ndarray, np.ndarray]] = {}
    if args.filters:
        print("\nFilter photometry:")
        for fpath in args.filters:
            name = os.path.splitext(os.path.basename(fpath))[0]
            fw, ft = load_filter_curve(fpath)
            filters[name] = (fw, ft)
            f, mag = filter_magnitude(
                wl,
                flux,
                fw,
                ft,
                reference_flux=args.filter_reference_flux,
                reference_magnitude=args.filter_reference_mag,
            )
            if math.isfinite(mag):
                print(f"  {name:20s}  flux={f:.6e}  mag={mag:.4f}")
            else:
                print(f"  {name:20s}  flux={f:.6e}  mag=undefined")

    if args.save_sed:
        save_sed(args.save_sed, wl, flux)
        print(f"Saved SED to {args.save_sed}")

    if args.plot:
        plot_sed(wl, flux, filters, out_path=args.plot)
        print(f"Saved plot to {args.plot}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())

