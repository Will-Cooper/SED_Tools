#!/usr/bin/env python3
"""Utility helpers for working with precomputed flux cubes.

This module exposes a small command line tool that can

* read the ``flux_cube.bin`` files generated by ``precompute_flux_cube.py``
* evaluate the spectral energy distribution (SED) at arbitrary
  combinations of (teff, logg, metallicity) using cubic Hermite
  interpolation in each axis
* compute bolometric fluxes / magnitudes
* fold SEDs through user supplied filter transmission curves
* create quick-look plots for the interpolated SED (and filters)

The binary format that :func:`precompute_flux_cube` writes is::

    int32 nt, nl, nm, nw
    float64[nt] teff_grid
    float64[nl] logg_grid
    float64[nm] meta_grid
    float64[nw] wavelengths
    float64[nw * nm * nl * nt] flux values stored with the trailing
        dimensions ordered as (wavelength, metallicity, logg, teff)

When loaded we restore the more natural shape
``(nt, nl, nm, nw)``.

Example usage from the command line::

    python flux_cube_tool.py --flux-cube data/stellar_models/MODEL/flux_cube.bin

When run interactively the tool reminds you of the valid parameter ranges,
prompts for any missing values, auto-discovers filter curves under
``data/filters/`` (or directories provided via ``--filters``), computes
synthetic photometry for each, and saves a diagnostic plot to ``plots/``.
Optional flags such as ``--plot`` and ``--save-sed`` allow overriding the
output locations or exporting the interpolated spectrum to disk.
    python flux_cube_tool.py \
        --flux-cube data/stellar_models/MODEL/flux_cube.bin \
        --teff 6000 --logg 4.5 --metallicity 0.0 \
        --filters data/filters/Johnson/U.dat data/filters/Johnson/B.dat \
        --plot sed.png --save-sed sed.csv

The CLI prints the bolometric flux / magnitude and the synthetic
photometry in each requested filter.  The plot overlays any supplied
filters (scaled to the SED peak) for visual sanity checks.
"""

from __future__ import annotations

import argparse
import math
import os
import struct
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Sequence, Tuple

FILTER_EXTENSIONS = {".dat", ".txt", ".csv"}

from typing import Dict, Iterable, List, Sequence, Tuple

import matplotlib.pyplot as plt
import numpy as np


@dataclass
class FluxCube:
    """In-memory representation of a pre-computed flux cube."""

    teff_grid: np.ndarray
    logg_grid: np.ndarray
    meta_grid: np.ndarray
    wavelengths: np.ndarray
    flux: np.ndarray  # shape (nt, nl, nm, nw)

    @classmethod
    def from_file(cls, path: str) -> "FluxCube":
        """Load a :class:`FluxCube` from a binary file."""

        with open(path, "rb") as fh:
            header = fh.read(16)
            if len(header) != 16:
                raise ValueError("Flux cube header truncated")
            nt, nl, nm, nw = struct.unpack("4i", header)
            teff = np.fromfile(fh, dtype=np.float64, count=nt)
            logg = np.fromfile(fh, dtype=np.float64, count=nl)
            meta = np.fromfile(fh, dtype=np.float64, count=nm)
            wavelengths = np.fromfile(fh, dtype=np.float64, count=nw)
            flux_expected = nt * nl * nm * nw
            flux_flat = np.fromfile(fh, dtype=np.float64)

        if flux_flat.size != flux_expected:
            raise ValueError(
                f"Flux cube body truncated: expected {flux_expected} values,"
                f" found {flux_flat.size}"
            )

        # Restore original (nt, nl, nm, nw) ordering.
        flux = flux_flat.reshape((nw, nm, nl, nt)).transpose(3, 2, 1, 0)

        return cls(teff, logg, meta, wavelengths, flux)

    # ------------------------------------------------------------------
    # Interpolation helpers

    def _hermite_interp_axis(
        self, values: np.ndarray, grid: np.ndarray, x: float, axis: int
    ) -> np.ndarray:
        """Perform cubic Hermite interpolation along one axis."""

        if values.shape[axis] < 2:
            raise ValueError("Need at least two grid points for Hermite interpolation")

        if not (grid[0] <= x <= grid[-1]):
            raise ValueError(
                f"Requested value {x} is outside interpolation range"
                f" [{grid[0]}, {grid[-1]}]"
            )

        idx = int(np.searchsorted(grid, x) - 1)
        idx = max(0, min(idx, len(grid) - 2))

        x0 = grid[idx]
        x1 = grid[idx + 1]
        h = x1 - x0
        t = (x - x0) / h if h != 0 else 0.0

        f0 = np.take(values, idx, axis=axis)
        f1 = np.take(values, idx + 1, axis=axis)

        m0 = self._axis_derivative(values, grid, idx, axis)
        m1 = self._axis_derivative(values, grid, idx + 1, axis)

        h00 = (2 * t**3) - (3 * t**2) + 1
        h10 = (t**3) - (2 * t**2) + t
        h01 = (-2 * t**3) + (3 * t**2)
        h11 = (t**3) - (t**2)

        return h00 * f0 + h10 * h * m0 + h01 * f1 + h11 * h * m1

    def _axis_derivative(
        self, values: np.ndarray, grid: np.ndarray, idx: int, axis: int
    ) -> np.ndarray:
        n = len(grid)

        if idx <= 0:
            f0 = np.take(values, 0, axis=axis)
            f1 = np.take(values, 1, axis=axis)
            return (f1 - f0) / (grid[1] - grid[0])
        if idx >= n - 1:
            f0 = np.take(values, n - 2, axis=axis)
            f1 = np.take(values, n - 1, axis=axis)
            return (f1 - f0) / (grid[n - 1] - grid[n - 2])

        f_prev = np.take(values, idx - 1, axis=axis)
        f_next = np.take(values, idx + 1, axis=axis)
        x_prev = grid[idx - 1]
        x_next = grid[idx + 1]
        return (f_next - f_prev) / (x_next - x_prev)

    # ------------------------------------------------------------------

    def interpolate_spectrum(self, teff: float, logg: float, meta: float) -> Tuple[np.ndarray, np.ndarray]:
        """Return ``(wavelength, flux)`` at the requested parameter point."""

        tmp = self._hermite_interp_axis(self.flux, self.teff_grid, teff, axis=0)
        tmp = self._hermite_interp_axis(tmp, self.logg_grid, logg, axis=0)
        flux = self._hermite_interp_axis(tmp, self.meta_grid, meta, axis=0)
        return self.wavelengths.copy(), flux


def integrate_flux(wavelength: np.ndarray, flux: np.ndarray) -> float:
    """Compute bolometric flux via trapezoidal integration."""

    return float(np.trapezoid(flux, wavelength))
    return float(np.trapz(flux, wavelength))


def bolometric_magnitude(
    wavelength: np.ndarray,
    flux: np.ndarray,
    reference_flux: float = 1.0,
    reference_magnitude: float = 0.0,
) -> Tuple[float, float]:
    """Return bolometric flux and magnitude."""

    fbol = integrate_flux(wavelength, flux)
    if fbol <= 0:
        mag = math.inf
    else:
        mag = reference_magnitude - 2.5 * math.log10(fbol / reference_flux)
    return fbol, mag


def load_filter_curve(path: str) -> Tuple[np.ndarray, np.ndarray]:
    """Load a two-column filter curve (wavelength, throughput)."""

    wavelengths: List[float] = []
    transmissions: List[float] = []

    with open(path, "r", encoding="utf-8") as fh:
        for line_no, raw_line in enumerate(fh, start=1):
            line = raw_line.strip()
            if not line or line.startswith("#"):
                continue

            normalized = line.replace(",", " ")
            parts = normalized.split()
            if len(parts) < 2:
                continue

            try:
                wl = float(parts[0])
                tr = float(parts[1])
            except ValueError:
                # Skip header or malformed rows gracefully.
                continue

            wavelengths.append(wl)
            transmissions.append(tr)

    if not wavelengths:
        raise ValueError(f"Filter file {path} does not contain numeric wavelength/transmission data")

    wavelength = np.asarray(wavelengths)
    transmission = np.asarray(transmissions)
    data = np.loadtxt(path, unpack=True)
    if data.shape[0] < 2:
        raise ValueError(f"Filter file {path} must contain at least two columns")
    wavelength, transmission = data[0], data[1]
    order = np.argsort(wavelength)
    return wavelength[order], transmission[order]


def filter_flux(
    sed_wavelength: np.ndarray,
    sed_flux: np.ndarray,
    filter_wavelength: np.ndarray,
    filter_transmission: np.ndarray,
) -> float:
    """Compute band-integrated flux through a filter curve."""

    interp_trans = np.interp(sed_wavelength, filter_wavelength, filter_transmission, left=0.0, right=0.0)
    numerator = np.trapezoid(sed_flux * interp_trans, sed_wavelength)
    denom = np.trapezoid(interp_trans, sed_wavelength)
    numerator = np.trapz(sed_flux * interp_trans, sed_wavelength)
    denom = np.trapz(interp_trans, sed_wavelength)
    if denom == 0:
        raise ValueError("Filter transmission integrates to zero")
    return float(numerator / denom)


def filter_magnitude(
    sed_wavelength: np.ndarray,
    sed_flux: np.ndarray,
    filter_wavelength: np.ndarray,
    filter_transmission: np.ndarray,
    reference_flux: float = 1.0,
    reference_magnitude: float = 0.0,
) -> Tuple[float, float]:
    """Compute synthetic flux and magnitude for a filter."""

    f = filter_flux(sed_wavelength, sed_flux, filter_wavelength, filter_transmission)
    if f <= 0:
        mag = math.inf
    else:
        mag = reference_magnitude - 2.5 * math.log10(f / reference_flux)
    return f, mag


def plot_sed(
    wavelength: np.ndarray,
    flux: np.ndarray,
    filters: Dict[str, Tuple[np.ndarray, np.ndarray]] = None,
    out_path: str | None = None,
) -> None:
    """Plot the interpolated SED and optional filter curves."""

    plt.figure(figsize=(10, 6))
    plt.plot(wavelength, flux, label="Interpolated SED", color="C0")

    if filters:
        peak = np.max(flux) if flux.size else 1.0
        for name, (fw, ft) in filters.items():
            scaled = ft / np.max(ft) * peak if np.max(ft) != 0 else ft
            plt.plot(fw, scaled, label=f"Filter {name}")

    plt.xlabel("Wavelength")
    plt.ylabel("Flux")
    plt.title("Interpolated Spectral Energy Distribution")
    plt.legend()
    plt.grid(True, alpha=0.3)

    if out_path:
        ensure_dir(os.path.dirname(out_path) or ".")
        plt.savefig(out_path, dpi=150)
    else:
        plt.show()
    plt.close()


def ensure_dir(path: str) -> None:
    if path:
        os.makedirs(path, exist_ok=True)


def save_sed(path: str, wavelength: np.ndarray, flux: np.ndarray) -> None:
    ensure_dir(os.path.dirname(path) or ".")
    data = np.column_stack((wavelength, flux))
    header = "wavelength flux"
    np.savetxt(path, data, header=header)


def prompt_for_parameter(name: str, units: str, grid: np.ndarray, provided: float | None) -> float:
    """Return the requested parameter, prompting if ``provided`` is ``None``."""

    if provided is not None:
        return provided

    lower = float(np.min(grid))
    upper = float(np.max(grid))
    prompt = f"Enter target {name} in {units} (range: {lower:g}–{upper:g} {units}): "

    while True:
        try:
            value_str = input(prompt).strip()
        except EOFError:
            raise SystemExit(f"Missing {name}; aborting.")

        try:
            value = float(value_str)
        except ValueError:
            print(f"Could not parse '{value_str}'. Please enter a numeric value.")
            continue

        if not (lower <= value <= upper):
            print(f"Value {value} is outside the supported range {lower:g}–{upper:g} {units}.")
            continue

        return value


def infer_filter_directories(flux_cube_path: str) -> List[Path]:
    """Return likely filter directories based on the flux cube location."""

    cube_path = Path(flux_cube_path).expanduser().resolve()
    candidates: List[Path] = []
    for parent in [cube_path.parent, *cube_path.parents]:
        candidate = parent / "filters"
        if candidate.is_dir():
            candidates.append(candidate)
    return candidates


def collect_filter_files(
    entries: Sequence[str] | None, flux_cube_path: str
) -> Tuple[List[Tuple[str, Path]], List[Path]]:
    """Discover filter files from explicit paths or inferred directories."""

    discovered: List[Path] = []
    search_roots: List[Path] = []

    def add_file(file_path: Path) -> None:
        if file_path.suffix.lower() in FILTER_EXTENSIONS and file_path.is_file():
            discovered.append(file_path)

    if entries:
        for item in entries:
            path = Path(item).expanduser().resolve()
            if path.is_dir():
                search_roots.append(path)
                for file_path in sorted(path.rglob("*")):
                    add_file(file_path)
            elif path.is_file():
                add_file(path)
            else:
                raise FileNotFoundError(f"Filter path '{item}' does not exist")
    else:
        for directory in infer_filter_directories(flux_cube_path):
            search_roots.append(directory)
            for file_path in sorted(directory.rglob("*")):
                add_file(file_path)

    unique_files = list(dict.fromkeys(discovered))
    if not unique_files:
        unique_roots: List[Path] = []
        seen_roots: set[Path] = set()
        for root in search_roots:
            resolved_root = root.resolve()
            if resolved_root not in seen_roots:
                unique_roots.append(resolved_root)
                seen_roots.add(resolved_root)
        return [], unique_roots

    if not search_roots:
        common_root = Path(os.path.commonpath([str(p.parent) for p in unique_files])).resolve()
        search_roots = [common_root]

    unique_roots: List[Path] = []
    seen_roots: set[Path] = set()
    for root in search_roots:
        resolved_root = root.resolve()
        if resolved_root not in seen_roots:
            unique_roots.append(resolved_root)
            seen_roots.add(resolved_root)
    search_roots = unique_roots

    filter_entries: List[Tuple[str, Path]] = []
    existing_names: set[str] = set()
    name_counts: Dict[str, int] = {}

    for file_path in unique_files:
        name: str | None = None
        for root in search_roots:
            try:
                rel = file_path.relative_to(root)
            except ValueError:
                continue
            else:
                name = rel.with_suffix("").as_posix()
                break

        if name is None:
            name = file_path.stem

        base_name = name
        counter = name_counts.get(base_name, 0)
        while name in existing_names:
            counter += 1
            name = f"{base_name}_{counter}"
        name_counts[base_name] = counter

        filter_entries.append((name, file_path))
        existing_names.add(name)

    return filter_entries, search_roots


def main(argv: Sequence[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Inspect and interpolate a flux cube")
    parser.add_argument("--flux-cube", required=True, help="Path to flux_cube.bin")
    parser.add_argument("--teff", type=float, help="Target effective temperature (K)")
    parser.add_argument("--logg", type=float, help="Target log g (dex)")
    parser.add_argument("--metallicity", type=float, help="Target metallicity [M/H] (dex)")
def main(argv: Sequence[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Inspect and interpolate a flux cube")
    parser.add_argument("--flux-cube", required=True, help="Path to flux_cube.bin")
    parser.add_argument("--teff", type=float, required=True, help="Target effective temperature")
    parser.add_argument("--logg", type=float, required=True, help="Target log g")
    parser.add_argument("--metallicity", type=float, required=True, help="Target metallicity")
    parser.add_argument("--bolometric-reference-flux", type=float, default=1.0,
                        help="Reference flux for bolometric magnitude (default: 1)")
    parser.add_argument("--bolometric-reference-mag", type=float, default=0.0,
                        help="Reference magnitude for bolometric magnitude (default: 0)")
    parser.add_argument("--filters", nargs="*", help="Filter files or directories (all filters discovered are used)")
    parser.add_argument("--filters", nargs="*", default=[], help="Filter curve files (two-column)")
    parser.add_argument("--filter-reference-flux", type=float, default=1.0,
                        help="Reference flux for filter magnitudes")
    parser.add_argument("--filter-reference-mag", type=float, default=0.0,
                        help="Reference magnitude for filter magnitudes")
    parser.add_argument("--plot", help="Write a diagnostic plot to this path (defaults to plots/)")
    parser.add_argument("--plot", help="Write a diagnostic plot to this path")
    parser.add_argument("--save-sed", help="Write interpolated SED (wavelength, flux) to a text file")

    args = parser.parse_args(argv)

    cube = FluxCube.from_file(args.flux_cube)

    teff = prompt_for_parameter("effective temperature", "K", cube.teff_grid, args.teff)
    logg = prompt_for_parameter("surface gravity (log g)", "dex", cube.logg_grid, args.logg)
    metallicity = prompt_for_parameter("metallicity [M/H]", "dex", cube.meta_grid, args.metallicity)

    wl, flux = cube.interpolate_spectrum(teff, logg, metallicity)
    wl, flux = cube.interpolate_spectrum(args.teff, args.logg, args.metallicity)

    fbol, mbol = bolometric_magnitude(
        wl,
        flux,
        reference_flux=args.bolometric_reference_flux,
        reference_magnitude=args.bolometric_reference_mag,
    )

    print(f"Interpolated SED at Teff={teff}, logg={logg}, [M/H]={metallicity}")
    print(f"Interpolated SED at Teff={args.teff}, logg={args.logg}, [M/H]={args.metallicity}")
    print(f"Bolometric flux: {fbol:.6e}")
    if math.isfinite(mbol):
        print(f"Bolometric magnitude: {mbol:.4f}")
    else:
        print("Bolometric magnitude: undefined (non-positive flux)")

    filters: Dict[str, Tuple[np.ndarray, np.ndarray]] = {}
    filter_entries, filter_roots = collect_filter_files(args.filters, args.flux_cube)
    if filter_entries:
        if args.filters:
            source_msg = ", ".join(str(path) for path in filter_roots) if filter_roots else "provided paths"
        else:
            source_msg = ", ".join(str(path) for path in filter_roots) or "inferred filter directories"
        print(f"\nFilter photometry (using {len(filter_entries)} filters from {source_msg}):")
        for name, fpath in filter_entries:
            fw, ft = load_filter_curve(str(fpath))
    if args.filters:
        print("\nFilter photometry:")
        for fpath in args.filters:
            name = os.path.splitext(os.path.basename(fpath))[0]
            fw, ft = load_filter_curve(fpath)
            filters[name] = (fw, ft)
            f, mag = filter_magnitude(
                wl,
                flux,
                fw,
                ft,
                reference_flux=args.filter_reference_flux,
                reference_magnitude=args.filter_reference_mag,
            )
            if math.isfinite(mag):
                print(f"  {name:30s}  flux={f:.6e}  mag={mag:.4f}")
            else:
                print(f"  {name:30s}  flux={f:.6e}  mag=undefined")
    else:
        print("\nNo filter files found; skipping filter photometry.")
                print(f"  {name:20s}  flux={f:.6e}  mag={mag:.4f}")
            else:
                print(f"  {name:20s}  flux={f:.6e}  mag=undefined")

    if args.save_sed:
        save_sed(args.save_sed, wl, flux)
        print(f"Saved SED to {args.save_sed}")

    if args.plot:
        plot_path = args.plot
    else:
        plot_filename = f"sed_T{teff:.0f}_g{logg:.2f}_M{metallicity:.2f}.png"
        plot_path = os.path.join("plots", plot_filename)

    plot_sed(wl, flux, filters, out_path=plot_path)
    print(f"Saved plot to {plot_path}")
        plot_sed(wl, flux, filters, out_path=args.plot)
        print(f"Saved plot to {args.plot}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())

